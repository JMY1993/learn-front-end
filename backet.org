* null undefined 区别
null 特殊的 null 值不属于上述任何一种类型，它构成了一个独立的类型，只包含 null 值

undefined 特殊值 undefined 和 null 一样自成类型。undefined 的含义是未被赋值。如果一个变量已被声明，但未被赋值，那么它的值就是 undefined
* 如果想要获得一些关于浏览器和其他引擎的兼容性信息，请看：

- http://caniuse.com ------ 每个功能都列有一个支持信息表格
  例如想看哪个引擎支持现代加密（cryptography）函数：http://caniuse.com/#feat=cryptography。
- https://kangax.github.io/compat-table ------ 一份列有语言功能以及引擎是否支持这些功能的表格。

* typeof操作符

typeof xx typeof(xx)

1. typeof null 的结果是 "object"。这其实是不对的。官方也承认了这是
   typeof 运算符的问题，现在只是为了兼容性而保留了下来。当然，null
   不是一个 object。null 有自己的类型，它是一个特殊值。再次强调，这是
   JavaScript 语言的一个错误。
2. typeof alert 的结果是 "function"，因为 alert 在 JavaScript
   语言中是一个函数。我们会在下一章学习函数，那时我们会了解到，在
   JavaScript 语言中没有一个特别的 "function" 类型。函数隶属于 object
   类型。但是 typeof 会对函数区分对待。
   这不是很正确的做法，但在实际编程中非常方便。

* 类型转换

- String()
- Number()

undefined: NaN //!!! 
null: 0 
true or false: 1 or 0 
string: 去掉首尾空格后的纯数字字符串中含有的数字。
如果剩余字符串为空，则转换结果为0。
否则，将会从剩余字符串中"读取"数字。当类型转换出现 error 时返回NaN。

#+BEGIN_SRC js
  alert(
  #+begin_quote
  #+end_quote
 Number("   123   ") ); // 123
  alert( Number("123z") );      // NaN（从字符串“读取”数字，读到 "z" 时出现错误）
  alert( Number("1 03") );      // NaN
  alert( Number(true) );        // 1
  alert( Number(false) );       // 0
#+END_SRC

- Boolean() 0, null, undefined, NaN, "" =
> false 其它都是true

#+BEGIN_SRC js
  console.log(Boolean("0")," ",Boolean(" ")) //true true !!!
  //因为“ ”和“0”都是非空字符串
#+END_SRC

** 将数字转换为任意进制的字符串,number.toString(base)
* 运算符和运算元

- 二元运算符 "+" 和其它

  - 二元"+" 可以做加法，也可以连接字符串

    #+BEGIN_SRC js
      1+1;   //2
      1+"1"; //"11"
      "1"+1; //"11" !!!字符串+数字会把数字转换为字符串，然后进行字符串连接
      1+1+"1"//"21" !!!js是从左到右运算的，所以会先计算 `1+1 //2`，然后计算`2+"1"//"21"`
    #+END_SRC

  - 二元"-"及其它二元运算符会把非数字运算符转化为数字

    #+BEGIN_SRC js
      2-"1"; //1
    #+END_SRC

  - 一元运算符"+"及数字转化 相当于调用了=Number()=

    #+BEGIN_SRC js
      +"21"; //21
      //要计算“21“+”21“的算数值
      +"21" + +"21"; // 42
    #+END_SRC

- 幂运算 **

  #+BEGIN_SRC js
    2**3; //8
  #+END_SRC

- 几个例子

#+BEGIN_SRC js
  "" + 1 + 0;     //"10"
  "" - 1 + 0;     //-1
  true + false;   //1
  6 / "3";        //2
  "2" * "3";      //6
  4 + 5 + "px";   //"9px"
  "$" + 4 + 5;    //"$45"
  "4" - 2;        //2
  "4px" - 2;      //NaN
  7 / 0;          //Infinity
  "  -9  " + 5;   //" -9 5"
  "  -9  " - 5;   //-14
  null + 1;       //1
  undefined + 1;  //NaN
  " \t \n" - 2;   //NaN !!!字符串转换为数字时，会忽略字符串的首尾处的空格字符。在这里，整个字符串由空格字符组成，包括 \t、\n 以及它们之间的“常规”空格。因此，类似于空字符串，所以会变为 0
#+END_SRC

* 值的比较

** 字符串比较

在比较字符串的大小时，JavaScript 会使用Unicode 编码顺序进行判定。
因此小写字母永远>大写字母。

- 首先比较两个字符串的首位字符大小。
- 如果一方字符较大（或较小），则该字符串大于（或小于）另一个字符串。算法结束。
- 否则，如果两个字符串的首位字符相等，则继续取出两个字符串各自的后一位字符进行比较。
- 重复上述步骤进行比较，直到比较完成某字符串的所有字符为止。
- 如果两个字符串的字符同时用完，那么则判定它们相等，否则未结束（还有未比较的字符）的字符串更大。

** 当对/不同类型/的值进行比较时，JavaScript
会首先将其转化为数字（number）再判定大小

相当于运行了Number()

** 对null和undefined比较

- null == undefined true

- null === undefined false

- 与0的比较

  #+BEGIN_SRC js
    alert( null > 0 );  // false
    alert( null == 0 ); // false
    alert( null >= 0 ); // true

    //因为相等性检查 == 和普通比较符 > < >= <= 的代码逻辑是相互独立的。进行值的比较时，null 会被转化为数字，因此它被转化为了 0。这就是为什么（3）中 null >= 0 返回值是 true，（1）中 null > 0 返回值是 false。
    //另一方面，undefined 和 null 在相等性检查 == 中不会进行任何的类型转换，它们有自己独立的比较规则，所以除了它们之间互等外，不会等于任何其他的值。这就解释了为什么（2）中 null == 0 会返回 false。

    //undefined 不应该被与其他值进行比较：
    alert( undefined > 0 ); // false，undefined被转换成了NaN
    alert( undefined < 0 ); // false，同上
    alert( undefined == 0 ); // false: undefined==null，只与null非全等
  #+END_SRC

- 规避值的比较可能产生的错误

  - 除了严格相等 === 外，其他凡是有 undefined/null
    参与的比较，我们都需要额外小心。
  - 除非你非常清楚自己在做什么，否则永远不要使用 >= > < <=
    去比较一个可能为 null/undefined 的变量。
  - 对于取值可能是 null/undefined
    的变量，请按需要/分别检查它的取值情况/。

* if (...) 语句会计算圆括号内的表达式，并将计算结果转换为布尔型。

相当于对括号内返回值执行=Boolean()= 数字 0、空字符串 ""、null、undefined
和 NaN 都会被转换成 false。因为他们被称为 “falsy" 值。

* 逻辑运算符

|| ：返回为真值的操作数 && ：返回为假值的操作数 ! ：布尔非运算

- 短路计算

  - =a || b || c || d= 返回第一个真值，如果都是假，返回最后一个值
  - =a && b && c && d= 返回第一个假值，如果都是真，返回最后一个值

- 代替if

  - =(predicate) || exp=; predicate为假，执行exp；
  - =(predicate) && exp=; predicate为真，执行exp；

- 转换Boolean值 =!!value= 相当于 =Boolean(value)=

  !!! 这里一起记忆一下=+value=转换为数字的用法

- 几个例子

  #+BEGIN_SRC js
    console.log(console.log(1) || 2 || console.log(3)) //控制台先打印出1，然后是2
    //console.log()返回值是undefined，是一个falsy值，所以会进一步向后取之，取到2后停止
  #+END_SRC

  [[https://zh.javascript.info/task/check-login][使用prompt的登陆验证]]
#+begin_src js
//使用prompt进行登陆校验
'use strict'
function loginCheck(){
let  userName = prompt("Enter your user name please:");
if (!userName){
  alert("Canceled!");
return 0;
} else if (!(userName === "Admin")) {
  alert("I don't know you");
return 0;
}

  let passwd = prompt("Enter your password please:");

  if (!passwd){ alert("Canceled!");
return 0;
} else if (!(passwd ==  "TheMaster"))
{ alert("Wrong password");
 return 0;
}

  alert("Welcome!");
return 0;
 }
#+end_src
* 控制结构

- break
- continue
** label:
  break或continue后面如果接标签，标签必须在语句之上定义。
** switch:
  比较switch和case的value是否/严格相等/

  - 注意=defaut=的使用
  - 注意每个case的=break=，没有break就会继续执行下一个case

- 一个例子
  [[https://zh.javascript.info/task/list-primes][输出素数（prime）]]

#+BEGIN_SRC js
  function isPrime(n) {
      for (let divider = 2 ; divider < n ; divider++) {
          if (n%divider === 0) {
              return false;
          }
      }
      return true;
  }

  function listPrime(n) {
      for (let prime = 2 ; prime <= n ; prime++) {
          if (isPrime(prime)) {
              console.log(`Found ${prime}!`);
          }
      }
      return 0;
  }
#+END_SRC

* for循环的循环体内let定义的变量，在循环体外是为定义的（不可见的）!!!
* 函数与函数表达式

** 语法区别

函数的花括号后面不需要=;= 函数表达式的花括号后面需要=;=
** 可见性区别
=严格模式下= ，当一个函数声明在一个代码块内时，它在该代码块内的任何位置都是可见的。但在代码块外不可见。
如果把函数表达式赋值给一个在代码块外声明的变量时，可以在代码块外调用

注意这里说的代码块是花括号的范围，不是/作用域/的概念。

例子： 
#+begin_src js
  let age = prompt("What is your age?", 18);

  // 有条件地声明一个函数
  if (age < 18) {

    function welcome() {
      alert("Hello!");
    }

  } else {

    function welcome() {
      alert("Greetings!");
    }

  }

  ///稍后使用 welcome(); // Error: welcome is not defined =而=js let
  age = 16; // 拿 16 作为例子

  if (age < 18) {
    welcome(); //   (运行) // | function welcome() { // |
    alert("Hello!"); // | 函数声明在声明它的代码块内任意位置都可用 } // | //
    welcome(); // / (运行)

  } else {

    function welcome() {
      alert("Greetings!");
    }

  }

  // 在这里，我们在花括号外部调用函数，我们看不到它们内部的函数声明。

  welcome(); // Error: welcome is not defined
#+end_src
* 对象的键

** =[key]= 的形式用来表示中间有空格的键名和变量名键名

** 计算属性->对象字面量中使用方括号

#+BEGIN_SRC js
  let fruit = prompt("Which fruit to buy?", "apple");

  let bag = {
    [fruit]: 5, // 属性名是从 fruit 变量中得到的
  };

  alert( bag.apple ); // 5 如果 fruit="apple"
#+END_SRC

** 属性值的简写

#+BEGIN_SRC js
  function makeUser(name, age) {
    return {
      name, // 与 name: name 相同
      age,  // 与 age: age 相同
      // ...
    };
  }
  //也可以与正常键值对的方式混用
  let user = {
    name,  // 与 name:name 相同
    age: 30
  };  
#+END_SRC

** in操作符左边是属性名（通常是一个带引号的字符串）

** 检测对象是否含有某个字符串

- =obj.key === undefined=
- =key in obj=

第一种方法存在检测不到的情况，如下例：

#+BEGIN_SRC js
  let obj = {
    test: undefined
  };

  alert( obj.test ); // 显示 undefined，所以属性不存在？

  alert( "test" in obj ); // true，属性存在！
#+END_SRC

* for...in 循环，/整数属性/会被进行排序，其他属性则按照创建的顺序显示

这里的"整数属性"指的是一个可以在不作任何更改的情况下转换为整数的字符串（包括整数到整数）。
也就是说，对于key，有Number(key) = key = String( Number(key) )。
比如，如果有obj["+49"]，key是"+49"。Number(key)=49，加号没有了，不是整数属性。
比如，如果有obj["1.2"]，1.2不是整数。

* 对象的相等判断，全等===和非全等==没有区别。只有在两个变量引用指向/同一个对象/时，才相等。

* 对象的浅拷贝Object.assign(obj, [src1, src1, src1,
...])，所有的src的属性都拷贝给obj，键名重复的，后面的会覆盖前面的

* 对象深拷贝，lodash库，=_.cloneDeep(obj)=

** 深拷贝算法 //：TODO

* 检查空对象

[[https://zh.javascript.info/task/is-empty][检查空对象]]

#+BEGIN_SRC js
  function isEmpty(obj) {
    for (let key in obj){
      return false;
    }
    return true;
  }
#+END_SRC

* JS垃圾回收（GC）的原理 （描述其原理）

从根开始遍历所有根变量的引用再标记这些被引用的变量，再遍历这些标记的变量，直到所有可达（reachable）的引用都被标记。
标记完成后，删除所有未被标记的变量。

* Symbol类型

** let id = Symbol("id") // 没有new，Symbol的参数是一个字符串

** Symbol类型不会被自动转换为字符串

** 显示一个Symbol：alert ( id.toString() )==> Symbol(id)

** 显示一个Symbol描述：alert (id.description)==>"id"，返回值是一个string

** for...in循环会跳过Symbol类型的键值对，但Object.assign会复制Symbol类型的键值对

* 全局Symbol注册表

** Symbol.for()

** Symbol.keyFor()

** 与Symbol的不同：

- Symbol 总是不同的值，即使它们有相同的名字。
- 如果我们希望同名的 Symbol 相等，那么我们应该使用全局注册表

  - =Symbol.for(key)= 返回（如果需要的话则创建）一个以 key作为名字的全局 Symbol。
  - 使用 Symbol.for 多次调用 key 相同的 Symbol 时，返回的就是同一个Symbol。

* 系统Symbol

#+BEGIN_SRC js
  Symbol.hasInstance
  Symbol.isConcatSpreadable
  Symbol.iterator
  Symbol.toPrimitive
#+END_SRC

* 获取Symbol的方法

** Object.getOwnPropertySymbols(obj)

** Reflect.ownKeys(obj)

** Symbol类型的属性不是百分百隐藏的

* 失去this的原因

** 原理

=.=或=[]=的方式调用方法时，会返回一个特殊的引用类型的值：=(base, name, strict)= -
base 是对象 - name 是属性名 - strict是是否为=use strict=模式
这个过程确定了函数体代码和this。这个引用类型的值仅在方法调用时使用，其它的赋值等操作等都会丢失这个值。

如果将这个引用类型作为右值赋值给其它变量，这个引用类型的值会被整体丢弃，只把函数引用赋值给了新的变量，这个时候对新的变量执行函数就会失去this。因为this根本没有传过来
** 一个例子：复杂运算失去this

#+BEGIN_SRC js
  let user = {
    name: "Jesse",
    sayName(){
      console.log(this.name);
    }
  }

  user.sayName(); //"Jesse"

  let sayName = user.sayName();
  sayName(); // 空白，因为this指向undefined

  (false||user.sayName)(); // 空白。因为或操作符查找第一个真值并返回，返回后的sayName丢失了特殊引用类型，this指向undefined

  (user.sayName)(); //"Jesse"。因为第一对括号可有可无，这里是设定计算顺序的，没有返回值的这个环节。
  // 与上一个例子的区别
  (false||user.sayName)(); //user.sayName返回一个引用类型，这个引用类型参与了`||`计算，这里丢失了引用类型
  (user.sayName)(); //user.sayName返回了一个引用类型，这个引用类型随后被调用，所以没有丢失引用类型。
#+END_SRC

** 另一个例子：对象字面量中使用this

#+BEGIN_SRC js
  let outerObj = {
    name: "outer",
    makeInner() {
      return {
        name: "inner",
        ref: this
      }
    }
  }
  outerObj.makeInner().ref.name; //"outer"
  outerObj.makeInner().name; //"inner"
#+END_SRC

* 链式调用的实现：每次调用后返回这个对象的自身

#+BEGIN_SRC js
  let ladder = {
    step: 0,
    up() {
      this.step++;
      return this;
    },
    down() {
      this.step--;
      return this;
    },
    showStep() {
      alert( this.step );
      return this;
    }
  }

  ladder.up().up().down().up().down().showStep(); // 1
#+END_SRC

* 对象转换

** 所有对象在布尔上下文中均为=true=

** 数值转换发生在对象相减或应用数学函数时（对象相加不是）

** 字符串转换通常发生在=alert(obj)=这样一个输出对象或类似的上下文中

** 对象转换的hint

*** "string"

#+begin_src js
  // 输出
  alert(obj);

  // 将对象作为属性键
  anotherObj[obj] = 123;
#+end_src

*** "number"
#+begin_src js
  // 显式转换
  let num = Number(obj);

  // 数学运算（除了二进制加法）
  let n = +obj; // 一元加法
  let delta = date1 - date2;

  // 小于/大于的比较
  let greater = user1 > user2;
#+end_src

*** "default"
在少数情况下发生，当运算符“不确定”期望值的类型时。

例如，二进制加法 + 可用于字符串（连接），也可以用于数字（相加），所以字符串和数字这两种类型都可以。因此，当二元加法得到对象类型的参数时，它将依据 "default" hint 来对其进行转换。

此外，如果对象被用于与字符串、数字或 symbol 进行 == 比较，这时到底应该进行哪种转换也不是很明确，因此使用 "default" hint。

  #+BEGIN_SRC js
    // 二元加法使用默认 hint
    let total = obj1 + obj2;

    // obj == number 使用默认 hint
    if (user == 1) { ... };
  #+END_SRC

* 对象转换的原理

** 调用转换顺序

调用 obj[Symbol.toPrimitive](hint) — 带有 symbol 键 Symbol.toPrimitive（系统 symbol）的方法，如果这个方法存在的话，
否则，如果 hint 是 "string" — 尝试 obj.toString() 和 obj.valueOf()，无论哪个存在。
否则，如果 hint 是 "number" 或 "default" — 尝试 obj.valueOf() 和 obj.toString()，无论哪个存在。

*** 一个定义obj[[file:hint][Symbol.toPrimitive]]方法的例子
#+begin_src js
  let user = {
    name: "John",
    money: 1000,

    [Symbol.toPrimitive](hint) {
      alert(`hint: ${hint}`);
      return hint == "string" ? `{name: "${this.name}"}` : this.money;
    }
  };

  // 转换演示：
  alert(user); // hint: string -> {name: "John"}
  alert(+user); // hint: number -> 1000
  alert(user + 500); // hint: default -> 1500
#+end_src
* 构造函数、new关键字及构造函数的return
** new关键字调用了构造函数时，发生了什么？

- 一个新的空对象被创建并分配给 this。

- 函数体执行。通常它会修改 this，为其添加新的属性。

- 返回 this 的值
** 构造器模式测试：new.target。返回一个布尔值，测试函数是否为new调用

** 构造函数的return

7. 如果 return 返回的是一个对象，则返回这个对象，而不是 this。

8. 如果 return 返回的是一个原始类型，则忽略。

* 数字进制与前缀
** 16进制 0x hexademical - x
** 2进制 0b binary - b
** 8进制 0o octal - o
* num.toString(base)，base是进制数字number类型。返回值是进制转化后的字符串化的数字，类型是string
* 数字后直接加点调用方法会产生错误
#+begin_src js
123456.toString(2) //错误，因为浮点数格式是1234.5678，编译器会把123456.当成浮点数的小数点
123456..toString(2) //正确
#+end_src

* 数字舍入
** Math.floor() //向下舍入3.7=>3, -2.1=>-3
** Math.ceil()  //向上摄入3.1=>4, -2.5=>-2 
** Math.round() //四舍五入
** Math.trunc() //直接舍弃小数位，ie不支持

** 保留n位小数 num.toFix(n)，返回字符串类型，若要数字，前面加上=+=

* isNaN()
  
判断是不是NaN
* typeof NaN // number
* isFinite(str)，参数是string
判断是不是常规数字。
- 如果是-Infinity Infinity或者其它字符串，返回false。
- 如果是数字字符串 //true
- null和"" //true
- boolean //true
- undefined //false
#+begin_src js
console.log(isFinite(null),isFinite(""), isFinite("null"), isFinite(false), isFinite(undefined));
//true true false true false
#+end_src
* 将字符串转换为数字
** Number()和+
是严格的，除了开头和结尾的空格，出现非数字就是NaN
** parseInt(numstr, base)，参数numchr是数字字符串
** parseFloat(numstr, base)
** 几个例子
[[https://zh.javascript.info/task/why-rounded-down][为什么 6.35.toFixed(1) == 6.3？]]
#+begin_src js
  alert( 6.35.toFixed(1) ); // 6.3
  //原因如下
  alert( 6.35.toFixed(20) ); // 6.34999999999999964473
  //所以使用.toFixed()会报错，因为精度有损失
  console.log( Math.round(6.35 * 10) / 10); // 6.35 -> 63.5 -> 64(rounded) -> 6.4，问题解决
#+end_src

[[https://zh.javascript.info/task/endless-loop-error][偶发的无限循环]]
#+begin_src js
let i = 0;
while (i != 10) {
  i += 0.2;
}

let i = 0;
while (i < 11) {
  i += 0.2;
  if (i > 9.8 && i < 10.2) console.log( i );
}
//9.999999999999996
//10.199999999999996
#+end_src
** 随机数和随机整数
[[https://zh.javascript.info/task/random-min-max][随机数]]
#+begin_src js
  //生成min 到 max之间的随机数（不包括max）
  function random (min, max) {
    let seed = Math.random();
    let seedAmp = seed * (max-min);
    return min+seedAmp;
  }
#+end_src
[[https://zh.javascript.info/task/random-int-min-max][随机整数]]
创建一个函数 randomInteger(min，max)，该函数会生成一个范围在 min 到 max 中的随机整数，包括 min 和 max。

在 min..max 范围中的所有数字的*出现概率*必须相同。

#+begin_src js
//仔细思考这个出现概率
  function randomInteger(min, max) {
    // here rand is from min to (max+1)
    let rand = min + Math.random() * (max + 1 - min);
    return Math.floor(rand);
  }
#+end_src
* 字符串长度属性str.length后面没有括号，不是方法
* 遍历字符串用for...of
* 改变字符串大小写(方法)
** str.toUpperCase()
** str.toLowerCase()
* 查找子*字符串*位置str.indexOf(substr, pos)，返回-1，0，或index
第二个参数是开始检索的位置
** 倒序str.lastIndexOf(substr, pos)
** 直接将indexOf()方法的返回值作为if（或其它需要Boolean的上下文）是不靠谱的
因为indexOf()方法的返回值可能是0，代表在字符串的起始位置就找到了substr，而0是falsy的，会被Boolean直接转换为false。
正确的方法是用~if (str.indexOf("Widget") != -1)~的形式
* 字符串查找的现代方法 
** str.includes(substr)
** str.startsWith(substr)
** str.endsWith(substr)
* 获取子字符串（注意与array的方法区分）
** str.slice(start [, end])，从start开始到end结束，不包括end。允许负值。
** str.substring(start [, end])，从start开始到end结束，不包括*两头*。start/end可以换位置，但是不允许负值
** str.substr(start [, length])，允许start为负数
* 字符串与UTF-16
** str.codePointAt(pos)，获得pos处字符的UTF-16编码（返回值：10进制数字）
** str.fromCodePoint(code)，用创建一个UTF-16编码对应的字符，参数code是10进制数字的UTF-16编码
** 使用16进制的UTF-16编码直接创建字符，'\u005a'
* 删除字符串前后空格 str.trim()
* 重复字符串n次，str.repeat(n)
* 几个字符串的例子
** 转换首字母大写的坑
[[https://zh.javascript.info/task/ucfirst][首字母转换]]
#+begin_src js
  function ucFirst(str) {
    if (!str) return str;//判断是否是空字符串

    //如果不加上一个if，也可以：
    //使用 str.charAt(0)，因为它总是会返回一个字符串（可能为空）

    return str[0].toUpperCase() + str.slice(1);
  }
    //按理说，这个函数应该返回一个字符串
    //如果说str本身是空的，那么返回值也应该是一个空字符串
    //但是如果这个retern中处理大小写转换的部分用的是str[0]的话，如果str本身就是一个空的字符串，str[0]返回的是undefined。那么undefined+String类型会返回"undefinestr”，导致最终返回“undefined”。
    //问题解决。
#+end_src
** 截断文本
#+begin_src js
  //创建函数 truncate(str, maxlength) 来检查 str 的长度，如果超过 maxlength —— 应使用 "…" 来代替 str 的结尾部分，长度仍然等于 maxlength。

  //函数的结果应该是截断后的文本（如果需要的话）。
  function truncate(str, maxlength) {
    if (str.length > maxlength) {
      return str.slice(0, maxlength-1) + "...";
    }
    return str;
  }
#+end_src
* 清空数组最简单的方法 arr.length = 0
* 数组的转换
** 数组没有 Symbol.toPrimitive，也没有 valueOf，它们只能执行 toString 进行转换
** 数组的toString()方法会返回以~,~隔开的元素列表的字符串
** 二元数组，相当于对所有元素数组也执行toString()
#+begin_src js
    let testArr = [
      [1,2,3],
      [2,3,4],
      [3,4,5]
    ]
  //1,2,3,2,3,4,3,4,5
#+end_src
** 输入数字求和
写出函数 sumInput()，要求如下：

使用 prompt 向用户索要值，并存在数组中。
当用户输入了非数字、空字符串或者点击“取消”按钮的时候，问询结束。
计算并返回数组所有项之和。
P.S. 0 是有效的数字，不要因为是 0 就停止问询。
#+begin_src js
function sumInput() {

  let numbers = [];

  while (true) {

    let value = prompt("A number please?", 0);

    // 应该结束了吗？
    if (value === "" || value === null || !isFinite(value)) break;

    numbers.push(+value);
  }

  let sum = 0;
  for (let number of numbers) {
    sum += number;
  }
  return sum;
}

alert( sumInput() );
// 使用isFinite而不是isNaN的原因：

// isFinite: if the argument is positive or negative Infinity or NaN or undefined return false
// isNaN: if the argument is NaN return true

// isNaN不包含超限检测，然而数值超限将导致加法计算不准确，因此需要考虑超限的情况。
#+end_src
** 最大子数组
[[https://zh.javascript.info/task/maximal-subarray][最大子数组]]
输入是以数字组成的数组，例如 arr = [1, -2, 3, 4, -9, 6].

任务是：找出所有项的和最大的 arr 数组的连续子数组。

写出函数 getMaxSubSum(arr)，用其找出并返回最大和。
#+begin_src js
  function getMaxSubSum(arr) {
    let maxSum = 0;
    let partialSum = 0;

    for (let item of arr) { // arr 中的每个 item
      partialSum += item; // 将其加到 partialSum
      maxSum = Math.max(maxSum, partialSum); // 记住最大值
      if (partialSum < 0) partialSum = 0; // 如果是负数就置为 0
    }

    return maxSum;
  }

  alert( getMaxSubSum([-1, 2, 3, -9]) ); // 5
  alert( getMaxSubSum([-1, 2, 3, -9, 11]) ); // 11
  alert( getMaxSubSum([-2, -1, 1, 2]) ); // 3
  alert( getMaxSubSum([100, -9, 2, -3, 5]) ); // 100
  alert( getMaxSubSum([1, 2, 3]) ); // 6
  alert( getMaxSubSum([-1, -2, -3]) ); // 0
#+end_src
算法思想：
一列数组可以简化为如下情况：
[leftSum,minusMin,rightSum]

如果 leftSum>minusMin && rightSum>minusMin，返回leftSum+minusMinx+rightSum
如果 leftSum>rightSum，且rightSum+minusMin<0，返回leftSum
如果 leftSum>rightSum，且rightSum+minusMin=0，返回leftSum
如果 leftSum+minusMin <0, rightSum+minusMin <0, 返回左右和的最大值

这个算法在循环过程中将数字累加，并记住最大值
如果遇到负数，且此暂时最大值小于负数，则从负数之后重新开始计算。
因为这证明左最大值小于此负数了，在这里打一个断点。

* 数组方法
** arr.splice(index[, deleteCount, elem1, ..., elemN])
** arr.slice(star[, end])，不包括end
** arr.concat(arg1,arg2)，如果arg1或者arg2是一个array，会被展开
*** 如果类似数组的对象具有 Symbol.isConcatSpreadable 属性，那么它就会被 concat 当作一个数组来处理（注意是array_like）
** arr.forEach()方法，为数组每个元素执行一个函数。函数执行结果会被抛弃
语法：
#+begin_src js
  arr.forEach(function(item, index, array) {
    // ... do something with item
  });
#+end_src
** indexOf & includes
~arr.indexOf(item, from)~ -  从索引 from 开始搜索 item，如果找到则返回索引，否则返回 -1。
~arr.lastIndexOf(item, from)~ — 和上面相同，只是从右向左搜索。
~arr.includes(item, from)~ — 从索引 from 开始搜索 item，如果找到则返回 true（译注：如果没找到，则返回 false）。
- 请注意，这些方法使用的是严格相等 === 比较。所以如果我们搜索 false，会精确到的确是 false 而不是数字 0。
- 此外，includes 的一个非常小的差别是它能正确处理NaN，而不像 indexOf/lastIndexOf：
#+begin_src js
  const arr = [NaN];
  alert( arr.indexOf(NaN) ); // -1（应该为 0，但是严格相等 === equality 对 NaN 无效）
  alert( arr.includes(NaN) );// true（这个结果是对的）
#+end_src
** 在数组中搜索
*** arr.find()
    #+begin_src js
      let result = arr.find(function(item, index, array) {
        // 如果返回 true，则返回 item 并停止迭代
        // 对于 falsy 则返回 undefined
      })
     #+end_src
*** arr.findIndex()
    语法与find相同，但是返回的是元素的index
*** arr.filter()，语法与find相同，但是返回满足条件的元素组成的新数组
** 转换数组
*** arr.map()
*** arr.sort() 有副作用，改变arr本身，回调函数中的a，b：b是第一个数，而a是第二个数!!!
*** arr.reverse() 有副作用，改变arr本身
* 使用 localeCompare for strings
对于许多字母，最好使用 str.localeCompare 方法正确地对字母进行排序，例如 Ö。
例如，让我们用德语对几个国家/地区进行排序：

str.localeCompare(str2)语法：
str.localeCompare(str2) 会根据语言规则返回一个整数，这个整数能表明 str 是否在 str2 前，后或者等于它：
str.localeCompare(str2)比较的是str是否大于str2!!!

如果 str 小于 str2 则返回负数。
如果 str 大于 str2 则返回正数。
如果它们相等则返回 0。

#+begin_src js
    let countries = ['Österreich', 'Andorra', 'Vietnam'];

    alert( countries.sort( (a, b) => a > b ? 1 : -1) ); // Andorra, Vietnam, Österreich（错的）

    alert( countries.sort( (a, b) => a.localeCompare(b) ) ); // Andorra,Österreich,Vietnam（对的！）
   #+end_src
* 分割字符串 / 粘合数组
** str.split(delim[, arrLength])
** array.join(glue) glue是用来“粘合”数组字符串的字符
* reduce / reduceRight
  语法：
  #+begin_src js
    let value = arr.reduce(function(accumulator, item, index, array) {
      // ...
    }, [initial]);
  #+end_src

 -  如果没有初始值，那么 reduce 会将数组的第一个元素作为初始值，并从第二个元素开始迭代。
 -  但是这种使用需要非常小心。如果数组为空，那么在没有初始值的情况下调用 reduce 会导致错误。
* Array.isArray(arr)。判断是否为数组不能用typeof，因为无论是数组还是对象，返回值都是object
* 数组的转换和reduce方法都支持thisArg，是最后一个参数。
* 数组方法备忘单：

** 添加/删除元素：

push(...items) — 向尾端添加元素，
pop() — 从尾端提取一个元素，
shift() — 从首端提取一个元素，
unshift(...items) — 向首端添加元素，
splice(pos, deleteCount, ...items) — 从 index 开始删除 deleteCount 个元素，并在当前位置插入 items。
slice(start, end) — 创建一个新数组，将从位置 start 到位置 end（但不包括 end）的元素复制进去。
concat(...items) — 返回一个新数组：复制当前数组的所有元素，并向其中添加 items。如果 items 中的任意一项是一个数组，那么就取其元素。
** 搜索元素：

indexOf/lastIndexOf(item, pos) — 从位置 pos 开始搜索 item，搜索到则返回该项的索引，否则返回 -1。
includes(value) — 如果数组有 value，则返回 true，否则返回 false。
find/filter(func) — 通过 func 过滤元素，返回使 func 返回 true 的第一个值/所有值。
findIndex 和 find 类似，但返回索引而不是值。
** 遍历元素：

forEach(func) — 对每个元素都调用 func，不返回任何内容。
** 转换数组：

map(func) — 根据对每个元素调用 func 的结果创建一个新数组。
sort(func) — 对数组进行原位（in-place）排序，然后返回它。
reverse() — 原位（in-place）反转数组，然后返回它。
split/join — 将字符串转换为数组并返回。
reduce(func, initial) — 通过对每个元素调用 func 计算数组上的单个值，并在调用之间传递中间结果。
** 其他：  – Array.isArray(arr) 检查 arr 是否是一个数组。

** 请注意，sort，reverse 和 splice 方法修改的是数组本身。!!!

** 较为不常用的方法：

~arr.some(fn) / arr.every(fn)~ 检查数组。

与 map 类似，对数组的每个元素调用函数 fn。如果任何/所有结果为 true，则返回 true，否则返回 false。

~arr.fill(value, start, end)~ — 从索引 start 到 end，用重复的 value 填充数组。

~arr.copyWithin(target, start, end)~ — 将从位置 start 到 end 的所有元素复制到 自身 的 target 位置（覆盖现有元素）。
* 原位（in place）的概念。修改原数组的数据，产生了副作用。（原位过滤、原位排序等）
* 数组方法的几个例子
** 转换为驼峰命名法
#+begin_src js
function camelize(str) {
  return str
    .split('-') // splits 'my-long-word' into array ['my', 'long', 'word']
    .map(
      // capitalizes first letters of all array items except the first one
      // converts ['my', 'long', 'word'] into ['my', 'Long', 'Word']
      (word, index) => index == 0 ? word : word[0].toUpperCase() + word.slice(1)
    )
    .join(''); // joins ['my', 'Long', 'Word'] into 'myLongWord'
}
// 注意这个解决方案没有考虑分割开的子string可能为空字符串的情况，因为默认不会出现这样的情况。
// 但是如果用 debug-mode--ver-1，这种，出现双下划线的情况，就会出现前文说到的undefined问题
#+end_src

** 非原位排序数组（无副作用的sort）
   #+begin_src js
     function copySorted(arr) {
       return arr.slice().sort();
     }

     let arr = ["HTML", "JavaScript", "CSS"];

     let sorted = copySorted(arr);

     alert( sorted );
     alert( arr );
     // str.slice直接浅拷贝一个array
   #+end_src
** 可扩展的calculator
#+begin_src js
function Calculator() {

  this.methods = {
    "-": (a, b) => a - b,
    "+": (a, b) => a + b
  };

  this.calculate = function(str) {

    let split = str.split(' '),
      a = +split[0],
      op = split[1],
      b = +split[2]

    if (!this.methods[op] || isNaN(a) || isNaN(b)) {
      return NaN;
    } //*

    return this.methods[op](a, b);
  }

  this.addMethod = function(name, func) {
    this.methods[name] = func;
  };
}
// 注意*行的条件判断：如果不存在方法、操作数非数字，直接返回NaN。
// 这里用isFinite()更好，可以处理infinity的情况
#+end_src
** 映射到对象
#+begin_src js
let john = { name: "John", surname: "Smith", id: 1 };
let pete = { name: "Pete", surname: "Hunt", id: 2 };
let mary = { name: "Mary", surname: "Key", id: 3 };

let users = [ john, pete, mary ];

let usersMapped = users.map(user => ({
  fullName: `${user.name} ${user.surname}`,
  id: user.id
}));//注意箭头函数返回值带大括号时需要用小括号扩起来，不然箭头函数会认为大括号内是函数体

/*
usersMapped = [
  { fullName: "John Smith", id: 1 },
  { fullName: "Pete Hunt", id: 2 },
  { fullName: "Mary Key", id: 3 }
]
*/

alert( usersMapped[0].id ); // 1
alert( usersMapped[0].fullName ); // John Smith
#+end_src
** 随机排列数组（shuffle）
[[https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle][Fisher-yates shuffle]] 算法
优点：没有排序（sort方法）开销，各种组合出现的概率相等

普通算法：
#+begin_src js
function shuffle(array) {
  array.sort(() => Math.random() - 0.5);
} //生成-0.5～0.5的随机数，作为排序因子

let arr = [1, 2, 3];
shuffle(arr);
alert(arr);
#+end_src
这种算法会造成各种组合出现概率不相等的问题，如下测试代码：
#+begin_src js
function shuffle(array) {
  array.sort(() => Math.random() - 0.5);
}

// 所有可能排列的出现次数
let count = {
  '123': 0,
  '132': 0,
  '213': 0,
  '231': 0,
  '321': 0,
  '312': 0
};

for (let i = 0; i < 1000000; i++) {
  let array = [1, 2, 3];
  shuffle(array);
  count[array.join('')]++;
}

// 显示所有可能排列的出现次数
for (let key in count) {
  alert(`${key}: ${count[key]}`);
}
#+end_src
结果：
123: 250706
132: 124425
213: 249618
231: 124880
312: 125148
321: 125223
123和213出现的概率远高于其它。不同组合的出现概率与不同引擎的不同实现相关
** 数组去重的性能问题
#+begin_src js
function unique(arr) {
  let result = [];

  for (let str of arr) {
    if (!result.includes(str)) {
      result.push(str);
    }
  }

  return result;
}

let strings = ["Hare", "Krishna", "Hare", "Krishna",
  "Krishna", "Krishna", "Hare", "Hare", ":-O"
];

alert( unique(strings) ); // Hare, Krishna, :-O
#+end_src
存在潜在的性能问题。

方法 result.includes(str) 在内部遍历数组 result，并将每个元素与 str 进行比较以找到匹配项。

所以如果 result 中有 100 个元素，并且没有任何一项与 str 匹配，那么它将遍历整个 result 并进行 100 次比较。如果 result 很大，比如 10000，那么就会有 10000 次的比较。

这本身并不是问题，因为 JavaScript 引擎速度非常快，所以遍历一个有 10000 个元素的数组只需要几微秒。

但是我们在 for循环中对 arr 的每个元素都进行了一次检测。

因此，如果 arr.length 是 10000，我们会有 10000 * 10000 = 1 亿次的比较。那真的太多了。

所以该解决方案仅适用于小型数组。

[[https://zh.javascript.info/map-set][集合和映射]]能够解决这个性能问题

* 区分iterable object和array like
** Iterable 如上所述，是实现 Symbol.iterator 方法的对象。
** Array-like 是有索引和 length 属性的对象，所以它们看起来很像数组。

* Symbol.iterator
  一个专门用于使对象可迭代的内置 symbol:

1. 当 for..of 循环启动时，它会调用这个方法（如果没找到，就会报错）。这个方法必须返回一个 迭代器（iterator） —— 一个有 next 方法的对象。
2. 从此开始，for..of 仅适用于这个被返回的对象。
3. 当 for..of 循环希望取得下一个数值，它就调用这个对象的 next() 方法。
next() 方法返回的结果的格式必须是 {done: Boolean, value: any}，当 done=true 时，表示迭代结束，否则 value 是下一个值。

#+begin_src js
  let range = {
    from: 1,
    to: 5
  };

  // 我们希望 for..of 这样运行：
  // for(let num of range) ... num=1,2,3,4,5

  range[Symbol.iterator] = function() {

    // ……它返回迭代器对象（iterator object）：
    // 2. 接下来，for..of 仅与此迭代器一起工作，要求它提供下一个值
    return {
      current: this.from,
      last: this.to,

      // 3. next() 在 for..of 的每一轮循环迭代中被调用
      next() {
        // 4. 它将会返回 {done:.., value :...} 格式的对象
        if (this.current <= this.last) {
          return { done: false, value: this.current++ };
        } else {
          return { done: true };
        }
      }
    };
  };

  // 现在它可以运行了！
  for (let num of range) {
    alert(num); // 1, 然后是 2, 3, 4, 5
  }
#+end_src

从技术上说，我们可以将它们合并，并使用 range 自身作为迭代器来简化代码。
但缺点是，现在不可能同时在对象上运行两个 for..of 循环了：它们将共享迭代状态，因为只有一个迭代器，即对象本身。但是两个并行的 for..of 是很罕见的，即使在异步情况下。
#+begin_src js
  let range = {
    from: 1,
    to: 5,

    [Symbol.iterator]() {
      this.current = this.from;
      return this;
    },

    next() {
      if (this.current <= this.to) {
        return { done: false, value: this.current++ };
      } else {
        return { done: true };
      }
    }
  };

  for (let num of range) {
    alert(num); // 1, 然后是 2, 3, 4, 5
 #+end_src

** 显式调用迭代器
 #+begin_src js
 let str = "Hello";

// 和 for..of 做相同的事
// for (let char of str) alert(char);

let iterator = str[Symbol.iterator]();

while (true) {
  let result = iterator.next();
  if (result.done) break;
  alert(result.value); // 一个接一个地输出字符
}
#+end_src

* Array.from(arrayLike/iterable)可以从可迭代对象和类数组对象中生成一个真正的数组，从而可以利用pop push等数组的方法。可选参数中可以传入一个mapFn，设置映射方式
完整语法： ~Array.from(obj[, mapFn, thisArg])~

* 原生字符串方法的坑

** str.split()不能正确处理“代理对”即UTF-16扩展字符，而Array.from可以。for...of也可以
   Array.from()的实现方式如下：
   #+begin_src js
     let str = '𝒳😂';

     let chars = []; // Array.from 内部执行相同的循环
     for (let char of str) {
       chars.push(char);
     }

     alert(chars);
    #+end_src
** 创建支持代理对的slice函数
   #+begin_src js
     function slice(str, start, end) {
       return Array.from(str).slice(start, end).join('');
     }

     let str = '𝒳😂𩷶';

     alert( slice(str, 1, 3) ); // 😂𩷶

     // 原生方法不支持识别代理对（译注：UTF-16 扩展字符）
     alert( str.slice(1, 3) ); // 乱码（两个不同 UTF-16 扩展字符碎片拼接的结果）
    #+end_src
* map
  语法：~let testMap = new Map([ key1, value1 ], [ key2, value2])~
  可以是一个带键值对的数组，也可以是其它可迭代对象。!!!

  方法和属性如下：

  new Map() —— 创建 map。
  map.set(key, value) —— 根据键存储值,返回修改后的map
  map.get(key) —— 根据键来返回值，如果 map 中不存在对应的 key，则返回 =undefined= 。
  map.has(key) —— 如果 key 存在则返回 true，否则返回 false。
  map.delete(key) —— 删除指定键的值，如果被删除的entry存在，返回true，如果不存在返回false
  map.clear() —— 清空 map。没有返回值
  map.size —— 返回当前元素个数。

  注意
  map[key] 不是使用 Map 的正确方式
  虽然 map[key] 也有效，例如我们可以设置 map[key] = 2，这样会将 map 视为 JavaScript 的 plain object，因此它暗含了所有相应的限制（没有对象键等）。

  所以我们应该使用 map 方法：set 和 get 等。
** Map 是怎么比较键的？
Map 使用 SameValueZero 算法来比较键是否相等。它和严格等于“===”差不多，但区别是 NaN 被看成是等于 NaN。所以 NaN 也可以被用作键。

这个算法不能被改变或者自定义。
** 链式调用：每一次 map.set 调用都会返回 map 本身，所以我们可以进行“链式”调用
** map迭代
*** 返回可迭代对象的方法：
   map.keys() —— 遍历并返回所有的键（returns an iterable for keys），
   map.values() —— 遍历并返回所有的值（returns an iterable for values），
   map.entries() —— 遍历并返回所有的实体（returns an iterable for entries）[key, value]，for..of 在默认情况下使用的就是这个。
*** map的迭代顺序，与插入值的顺序相同
    迭代的顺序与插入值的顺序相同。与普通的 Object 不同，Map 保留了此顺序。
*** map的forEach()方法
    #+begin_src js
      // 对每个键值对 (key, value) 运行 forEach 函数
      recipeMap.forEach( (value, key, map) => {
        alert(`${key}: ${value}`); // cucumber: 500 etc
      });
     #+end_src
** map与数组的转换
   
*** Object.entries() 返回对象的键值对数组
*** Object.fromEntries() 从键值对数组创建对象
*** 从对象创建map
    #+begin_src js
      let fruitsObj = {
        apple: 10,
        banana: 11,
        orange: 3,
        tomato: 5
      };
      let fruitsEntries = Object.entries(fruitsObj);
      let fruitsMap = new Map(fruitsEntries);

      fruitsMap.get("orange");
     #+end_src
*** 从map创建对象
    #+begin_src js
      let hard = "***";
      let medium = "**-";
      let easy = "*--";
      let editorsMap = new Map([
        ["emacs", hard],
        ["vim", hard],
        ["vscode", medium],
        ["notepad", easy]
      ])
      let editorsObj = Object.fromEntries(editorsMap.entries());
      //let editorsObj = Object.fromEntries(editorsMap);
      //上面的代码作用也是一样的，因为 Object.fromEntries 期望得到一个可迭代对象作为参数，而不一定是数组。并且 map 的标准迭代会返回跟 map.entries() 一样的键/值对。因此，我们可以获得一个普通对象（plain object），其键/值对与 map 相同。

      for (let editorName in editorsObj) {
        console.log(`the editor ${editorName} has the hardness of ${editorsObj[editorName]}`);
      }
     #+end_src
* set
  new Set(iterable) —— 创建一个 set，如果提供了一个 iterable 对象（通常是数组），将会从数组里面复制值到 set 中。
  set.add(value) —— 添加一个值，返回 set 本身
  set.delete(value) —— 删除值，如果 value 在这个方法调用的时候存在则返回 true ，否则返回 false。
  set.has(value) —— 如果 value 在 set 中，返回 true，否则返回 false。
  set.clear() —— 清空 set。
  set.size —— 返回元素个数。
** set的性能优势：Set 的替代方法可以是一个用户数组，用 arr.find 在每次插入值时检查是否重复。但是这样性能会很差，因为这个方法会遍历整个数组来检查每个元素。Set 内部对唯一性检查进行了更好的优化。
** set迭代!!!
   set.keys() —— 遍历并返回所有的值（returns an iterable object for values），
   set.values() —— 与 set.keys() 作用相同，这是为了兼容 Map，
   set.entries() —— 遍历并返回所有的实体（returns an iterable object for entries）[value, value]，它的存在也是为了兼容 Map。!!!
*** forEach()
    语法
    #+begin_src js
      let set = new Set(["oranges", "apples", "bananas"]);

      for (let value of set) console.log(value);

      // 与 forEach 相同：
      set.forEach((value, valueAgain, set) => {
        console.log(value);
      });
     #+end_src
    forEach 的回调函数有三个参数：一个 value，然后是 同一个值 valueAgain，最后是目标对象。没错，同一个值在参数里出现了两次。

    forEach 的回调函数有三个参数，是为了与 Map 兼容。当然，这看起来确实有些奇怪。但是这对在特定情况下轻松地用 Set 代替 Map 很有帮助，反之亦然。
** 几个例子
*** 过滤字谜
    [[https://zh.javascript.info/task/filter-anagrams][anagrams]]
    #+begin_src js
      function aclean(arr) {
        let map = new Map();

        for (let word of arr) {
          // 将单词 split 成字母，对字母进行排序，之后再 join 回来
          let sorted = word.toLowerCase().split('').sort().join(''); // (*)
          map.set(sorted, word);
        }

        return Array.from(map.values());
      }

      let arr = ["nap", "teachers", "cheaters", "PAN", "ear", "era", "hectares"];

      alert( aclean(arr) );

      // 不用map的方式

      function aclean(arr) {
        let obj = {};

        for (let i = 0; i < arr.length; i++) {
          let sorted = arr[i].toLowerCase().split("").sort().join("");
          obj[sorted] = arr[i];
        }

        return Object.values(obj);
      }

      let arr = ["nap", "teachers", "cheaters", "PAN", "ear", "era", "hectares"];

      alert( aclean(arr) );
    #+end_src

* set/map.keys()返回的是可迭代对象不是数组，所以不能用push等方法。如果想用，可以用Array.from()转换后用
* 获取对象的keys、values、entries：Object.keys(obj), Object.values(obj), Object.entries(obj)，不能直接用obj.values这种形式!!!
* for...of，forEach遍历的坑
  如果数组是空的，不会执行遍历。比如我之前做的注册表的例子：
  如果遍历注册表，如果注册表内没有元素，注册进去。
  这个例子中，我对注册表遍历。
  遍历完成后，return 一个true。
  注册表初始值是{},结果所有结果都返回true，因为空对象for...of是不执行遍历的。
  所以直接返回true了。
  这时候要在遍历之前加上一个判断条件，如果注册表是空的，直接返回false。
* weakMap & weakSet
** 两个weak类型都只能存储对象键，不能存储primitive类型的值
** 两个weak类型的方法有限制，无法显示长度，无法迭代（也就无法列出keys和values）
- weakMap的方法
  weakMap.get(key)
  weakMap.set(key, value)
  weakMap.delete(key)
  weakMap.has(key)
- 跟 Set 一样，WeakSet 支持 add，has 和 delete 方法，但不支持 size 和 keys()，并且不可迭代。
** 用例：额外的数据存储和缓存
- 假如我们正在处理一个“属于”另一个代码的一个对象，也可能是第三方库，并想存储一些与之相关的数据，那么这些数据就应该与这个对象共存亡 — 这时候 WeakMap 正是我们所需要的利器。
我们将这些数据放到 WeakMap 中，并使用该对象作为这些数据的键，那么当该对象被垃圾回收机制回收后，这些数据也会被自动清除。
- 另外一个普遍的例子是缓存：当一个函数的结果需要被记住（“缓存”），这样在后续的对同一个对象的调用时，就可以重用这个被缓存的结果。
#+begin_src js
  // 📁 cache.js
  let cache = new WeakMap();

  // 计算并记结果
  function process(obj) {
    if (!cache.has(obj)) {
      let result = /* calculate the result for */ obj;

      cache.set(obj, result);
    }

    return cache.get(obj);
  }

  // 📁 main.js
  let obj = {/* some object */};

  let result1 = process(obj);
  let result2 = process(obj);

  // ……稍后，我们不再需要这个对象时：
  obj = null;

  // 无法获取 cache.size，因为它是一个 WeakMap，
  // 要么是 0，或即将变为 0
  // 当 obj 被垃圾回收，缓存的数据也会被清除
#+end_src
* 对象的迭代和map/set迭代
** 语法区别：object的迭代是Object.keys(obj)，map是mapVar.keys()
** 返回值区别
   |          | Map        | Object        |
   |----------+------------+---------------|
   | 调用语法 | map.keys() | Object.keys() |
   | 返回值   | 可迭代项   | “真正的数组”        |
** Object.keys/values/entries 会忽略 symbol 属性
*** 如果想要得到symbol属性
- Object.getOwnPropertySymbols，它会返回一个只包含 Symbol 类型的键的数组
- Reflect.ownKeys(obj)，它会返回 =所有= 键
* 数组解构赋值
** 添加额外逗号以忽略不要的元素
#+begin_src js
// 不需要第二个元素
let [firstName, , title] = ["Julius", "Caesar", "Consul", "of the Roman Republic"];

alert( title ); // Consul
#+end_src
** 等号右侧可以是任何可迭代对象
#+begin_src js
let [a, b, c] = "abc"; // ["a", "b", "c"]
let [one, two, three] = new Set([1, 2, 3]);
#+end_src
** 等号左侧可以使用任何可以被赋值的“东西”
#+begin_src js
let user = {};
[user.name, user.surname] = "Ilya Kantor".split(' ');

alert(user.name); // Ilya
#+end_src
** 与Object.entries()联动，进行循环操作
#+begin_src js
let user = {
  name: "John",
  age: 30
};

// 循环遍历键—值对
for (let [key, value] of Object.entries(user)) {
  alert(`${key}:${value}`); // name:John, then age:30
}
#+end_src
** 与map对象联动，进行循环操作
#+begin_src js
let user = new Map();
user.set("name", "John");
user.set("age", "30");

for (let [key, value] of user) {
  alert(`${key}:${value}`); // name:John, then age:30
}
#+end_src
!!!map本身就是可迭代对象，这里不需要使用egMap.entries()，直接使用egMap就可以
** ...操作符，取得剩余元素
#+begin_src js
let [name1, name2, ...rest] = ["Julius", "Caesar", "Consul", "of the Roman Republic"];

alert(name1); // Julius
alert(name2); // Caesar

// 请注意，`rest` 的类型是数组
alert(rest[0]); // Consul
alert(rest[1]); // of the Roman Republic
alert(rest.length); // 2
#+end_src
** 基于复杂表达式的默认值
默认值等号右边可以是任何复杂表达式，只有没有被赋值的变量等号右侧的表达式会被求值
#+begin_src js
// 只会提示输入姓氏
let [name = prompt('name?'), surname = prompt('surname?')] = ["Julius"];

alert(name);    // Julius（来自数组）
alert(surname); // 你输入的值
#+end_src
* 对象的解构赋值
** 另外指定变量名
#+begin_src js
let options = {
  title: "Menu",
  width: 100,
  height: 200
};

// { sourceProperty: targetVariable }
let {width: w, height: h, title} = options;

// width -> w
// height -> h
// title -> title

alert(title);  // Menu
alert(w);      // 100
alert(h);      // 200
#+end_src
** 对象解构赋值默认值语法
#+begin_src js
let options = {
  title: "Menu"
};

let {width: w = 100, height: h = 200, title} = options;

alert(title);  // Menu
alert(w);      // 100
alert(h);      // 200
#+end_src
** 剩余模式
与数组的剩余模式不同，对象解构赋值的rest是一个对象，而数组的rest是一个数组
#+begin_src js
let options = {
  title: "Menu",
  height: 200,
  width: 100
};

// title = 名为 title 的属性
// rest = 存有剩余属性的对象
let {title, ...rest} = options;

// 现在 title="Menu", rest={height: 200, width: 100}
alert(rest.height);  // 200
alert(rest.width);   // 100
#+end_src
** 不使用let时使用解构赋值的坑
#+begin_src js
let title, width, height;

// 这一行发生了错误
{title, width, height} = {title: "Menu", width: 200, height: 100};
#+end_src
因为等号前面的大括号被js解释器认为是一个代码块，如果要解决这个问题，只要用括号扩起来就可以了（与箭头函数的例子相同）：
#+begin_src js
let title, width, height;

// 现在可以了
({title, width, height}) = {title: "Menu", width: 200, height: 100};
#+end_src
** 嵌套解构（深层解构）
- 浅层的对象没有被赋值，见下例的items和size
- 嵌套解构仍然可以重命名变量
- 嵌套解构的时候等号左侧和右侧必须有相同的结构（指的是层次，不是变量多少）
#+begin_src js
  let options = {
    size: {
      width: 100,
      height: 200
    },
    items: ["Cake", "Donut"],
    extra: true
  };

  // 为了清晰起见，解构赋值语句被写成多行的形式
  let {
    size: { // 把 size 赋值到这里
      width : w,
      height
    },
    items: [item1, item2], // 把 items 赋值到这里
    title = "Menu" // 在对象中不存在（使用默认值）
  } = options;

  console.log(title);  // Menu
  console.log(width);  // 100
  console.log(height); // 200
  console.log(item1);  // Cake
  console.log(item2);  // Donut
  console.log(items);  //error
  console.log(w);      //100
  console.log(size);   //error
#+end_src
* 时间（Date类型）
** 基础语法
- let testDate = new Date(ms)
如果不带参数，返回现在的时间
- let testDate = new Date(str)
字符串的内容会被自动解析，相当于将使用了Date.parse(str)的返回值带入ms
!!!所以可以直接用另一个Date类型数据作为参数传给new Date(date)，这在拷贝日期的时候非常有用

- let testDate = new Date(year, month, date, hours, minutes, seconds, ms)
使用当前时区中的给定组件创建日期。只有前两个参数是必须的
  + year 必须是四位数：2013 是合法的，98 是不合法的。
  + month 计数从 0（一月）开始，到 11（十二月）结束。
  + date 是当月的具体某一天，如果缺失，则为默认值 1。
  + 如果 hours/minutes/seconds/ms 缺失，则均为默认值 0。

** 时间基准1970-1-1，ms指的是时间基准到指定的时间的毫秒数，1970-1-1之前的时间是负的时间戳
** 访问日期组件
  -  getFullYear()
     获取年份（4 位数）
  -  getMonth()
     获取月份，从 0 到 11。
  -  getDate()
     获取当月的具体日期，从 1 到 31，这个方法名称可能看起来有些令人疑惑。
  -  getHours()，getMinutes()，getSeconds()，getMilliseconds()
     获取相应的时间组件。
  !!! 是getFullYear()，不是getYear()
  -  getDay()
     获取一周中的第几天，从 0（星期日）到 6（星期六）。第一天始终是星期日，在某些国家可能不是这样的习惯，但是这不能被改变。
!!! 以上的所有方法返回的组件都是基于当地时区的。
** 访问日期组件的UTC变体
与当地时区的 UTC 对应项，它们会返回基于 UTC+0 时区的日、月、年等：getUTCFullYear()，getUTCMonth()，getUTCDay()。只需要在 "get" 之后插入 "UTC" 即可。
** 没有utc变体的访问日期组件
getTime()
返回日期的时间戳 —— 从 1970-1-1 00:00:00 UTC+0 开始到现在所经过的毫秒数。

getTimezoneOffset()
返回 UTC 与本地时区之间的时差，以 =分钟= 为单位：
** 设置日期组件
setFullYear(year, [month], [date])
setMonth(month, [date])
setDate(date)
setHours(hour, [min], [sec], [ms])
setMinutes(min, [sec], [ms])
setSeconds(sec, [ms])
setMilliseconds(ms)
setTime(milliseconds)（使用自 1970-01-01 00:00:00 UTC+0 以来的毫秒数来设置整个日期）

除了setTime(ms)都有utc变体

** 时间的自动校准（快速获得某一日期后的日期）
*** 时间超出范围会被自动调整
#+begin_src js
let date = new Date(2013, 0, 32); // 32 Jan 2013 ?!?
alert(date); // ……是 1st Feb 2013!
#+end_src
*** 快速获得时间
#+begin_src js
let date = new Date(2016, 1, 28);
date.setDate(date.getDate() + 2);

alert( date ); // 1 Mar 2016
#+end_src
*** 时间可以设置为负值
#+begin_src js
let date = new Date(2016, 0, 2); // 2016 年 1 月 2 日

date.setDate(1); // 设置为当月的第一天
alert( date );

date.setDate(0); // 天数最小可以设置为 1，所以这里设置的是上一月的最后一天
alert( date ); // 31 Dec 2015
#+end_src
** 日期转化为数字和日期差值
*** 转化为数字
#+begin_src js
let date = new Date();
alert(+date); // 以毫秒为单位的数值，与使用 date.getTime() 的结果相同
#+end_src
*** 时间差值
日期相减的结果是以ms为单位的时间差
#+begin_src js
let start = new Date(); // 开始测量时间

// do the job
for (let i = 0; i < 100000; i++) {
  let doSomething = i * i * i;
}

let end = new Date(); // 结束测量时间

alert( `The loop took ${end - start} ms` );
#+end_src
** Date.now()不会创建对象，会创建一个1970-1-1到现在的时间戳（number类型）
因此它更快，而且不会对垃圾处理造成额外的压力。

这种方法很多时候因为方便，又或是因性能方面的考虑而被采用，例如使用 JavaScript 编写游戏或其他的特殊应用场景。
** Date.parse()
字符串的格式应该为：YYYY-MM-DDTHH:mm:ss.sssZ，其中：

- YYYY-MM-DD —— 日期：年-月-日。
- 字符 "T" 是一个分隔符。
- HH:mm:ss.sss —— 时间：小时，分钟，秒，毫秒。
- 可选字符 'Z' 为 +-hh:mm 格式的时区。单个字符 Z 代表 UTC+0 时区。
- 简短形式也是可以的，比如 YYYY-MM-DD 或 YYYY-MM，甚至可以是 YYYY。

Date.parse(str) 调用会解析给定格式的字符串，并返回时间戳（自 1970-01-01 00:00:00 起所经过的毫秒数）。如果给定字符串的格式不正确，则返回 NaN。
** performance.now()方法来给出从页面加载开始的以毫秒为单位的微秒数（精确到毫秒的小数点后三位）
* JSON
** JSON.stringify()
会被跳过javascript数据类型
- 函数、方法
- Symbol属性
- undefined数据

!!!不得有循环引用
*** JSON.stringify(value[, replacer, space])的replacer语法
#+begin_src js
let room = {
  number: 23
};

let meetup = {
  title: "Conference",
  participants: [{name: "John"}, {name: "Alice"}],
  place: room // meetup 引用了 room
};

room.occupiedBy = meetup; // room 引用了 meetup

alert( JSON.stringify(meetup, function replacer(key, value) {
  alert(`${key}: ${value}`);
  return (key == 'occupiedBy') ? undefined : value;
}));

/* key:value pairs that come to replacer:
:             [object Object]
title:        Conference
participants: [object Object],[object Object]
0:            [object Object]
name:         John
1:            [object Object]
name:         Alice
place:        [object Object]
number:       23
*/
#+end_src
*** 上例中揭示了JSON.stringify()replacer的转换顺序：
- 先把对象整个带入，key是空的，value是自身
- 然后是entries
- 遇到复杂数据类型，先把数据本身带入，然后深入

如果值被跳过了，return为 undefined。
*** 自定义toJSON()方法
- JSON.stringify()遇到自定义toJSON代码时，会直接调用，并把toJSON的返回值作为转换结果（或是相应key的value）
** JSON.parse()
*** reviver
例子：
#+begin_src js
let str = '{"title":"Conference","date":"2017-11-30T12:00:00.000Z"}';

let meetup = JSON.parse(str, function(key, value) {
  if (key == 'date') return new Date(value);
  return value;
});

alert( meetup.date.getDate() ); //转换后的date键现在对应的value是Date数据类型了
#+end_src
** 例子：排除循环引用
#+begin_src js
  let room = {
    number: 23
  };

  let meetup = {
    title: "Conference",
    occupiedBy: [{name: "John"}, {name: "Alice"}],
    place: room
  };

  // 循环引用
  room.occupiedBy = meetup;
  meetup.self = meetup;


  alert( JSON.stringify(meetup, function replacer(key, value) {
    return (key != "" && value == meetup) ? undefined : value;
  }));
  //这里除了判断value是不是meetup，还要判断是不是空键。因为JSON.stringify()的replacer是从 ~"":meetup~ 开始迭代的 !!!
  /* 结果应该是：
  {
    "title":"Conference",
    "occupiedBy":[{"name":"John"},{"name":"Alice"}],
    "place":{"number":23}
  }
  ,*/
#+end_src
* 输出一个单链表
#+begin_src js
  let list = {
    value: 1,
    next: {
      value: 2,
      next: {
        value: 3,
        next: {
          value: 4,
          next: null
        }
      }
    }
  };
  //正向输出递归解法
  function printList(list) {

    alert(list.value); // 输出当前元素

    if (list.next) {
      printList(list.next); // 链表中其余部分同理
    }

  }

  printList(list);
  //正向输出循环解法
  function printList(list) {
    let tmp = list;

    while (tmp) {
      alert(tmp.value);
      tmp = tmp.next;
    }

  }

  printList(list);
  //反向输出递归解法
  function printBackward(list) {
    if (list.next) {
      printBackward(list.next)
    }
    console.log(list.value);
  }
  //反向输出循环解法
  function printReverseList(list) {
    let arr = [];
    let tmp = list;

    while (tmp) {
      arr.push(tmp.value);
      tmp = tmp.next;
    }

    for (let i = arr.length - 1; i >= 0; i--) {
      alert( arr[i] );
    }
  }

  printReverseList(list);
  //递归解法实际上也是这样做的：它顺着链表，记录每一个嵌套调用里链表的元素（在执行上下文堆栈里），然后输出它们。
#+end_src
* rest参数必须放到参数列表最后：function testFun(arg1, arg2, ...argN){}
* arguments类似rest参数，但是arguments不是数组对象。箭头函数没有arguments
* spread语法
** 把数组转换为参数列表
#+begin_src js
let arr = [3, 5, 1];

alert( Math.max(...arr) ); // 5（spread 语法把数组转换为参数列表）
#+end_src
** spread语法接收的参数会被保存在arr，arr是一个真正的数组。这一点与arugments变量不同
** 传递多个可迭代对象
#+begin_src js
let arr1 = [1, -2, 3, 4];
let arr2 = [8, 3, -8, 1];

alert( Math.max(...arr1, ...arr2) ); // 8
#+end_src
** spread与常规值结合使用
#+begin_src js
let arr1 = [1, -2, 3, 4];
let arr2 = [8, 3, -8, 1];

alert( Math.max(1, ...arr1, 2, ...arr2, 25) ); // 25
#+end_src
** 使用 spread 语法来合并数组
#+begin_src js
let arr = [3, 5, 1];
let arr2 = [8, 9, 15];

let merged = [0, ...arr, 2, ...arr2];

alert(merged); // 0,3,5,1,2,8,9,15（0，然后是 arr，然后是 2，然后是 arr2）
#+end_src
** spread语法中 ~...~ 后面可以是任何可迭代对象，不只是数组，例如字符串、定义了Symbol.iterator的普通对象等。
** spread语法和Array.from()的区别：Array.from()可以转化array-like对象，而spread语法不能。所以Array.from()应用范围更广
** spread语法代替Object.assign()写法更简洁
*** Object.assign([], arr) <==> [...arr]
*** Object.assign({}, obj) <==> {...obj}
* 代码块内声明的变量仅在代码块内可见
代码块有其自身的词法环境，块之外（或另一个脚本内）的代码访问不到代码块内的变量
#+begin_src js
{
  // 使用在代码块外不可见的局部变量做一些工作

  let message = "Hello"; // 只在此代码块内可见

  alert(message); // Hello
}

alert(message); // Error: message is not defined
#+end_src
所以可以使用代码块隔离变量声明
* 闭包与v8引擎优化
理论上当函数可达时，它外部的所有变量也都将存在。

但在实际中，JavaScript 引擎会试图优化它。它们会分析变量的使用情况，如果从代码中可以明显看出有未使用的外部变量，那么就会将其删除。

在 V8（Chrome，Opera）中的一个重要的副作用是，此类变量在调试中将不可用。
#+begin_src js
let value = "Surprise!";

function f() {
  let value = "the closest value";

  function g() {
    debugger; // 在 console 中：输入 alert(value); Surprise!
  }

  return g;
}

let g = f();
g();
#+end_src

输出surprise是因为v8引擎优化掉了f()函数内的value变量

#+begin_src js
let value = "Surprise!";

function f() {
  let value = "the closest value";

  function g() {
    let valueCopy = value;
    debugger; // 在 console 中：输入 alert(value); the closest value
  }

  return g;
}

let g = f();
g();
#+end_src

这段修改后的代码中使用了f词法环境中的value变量，所以v8引擎没有把value回收。

** 一个变量可见性的坑!!!
[[https://zh.javascript.info/task/let-scope][变量存在吗？]]
#+begin_src js
  //看这段代码
  let x = 1;
  function func() {
    console.log(x);
    let x = 2;
  }
  func();//错误

  /* 从程序执行进入代码块（或函数）的那一刻起，变量就开始进入“未初始化”状态。它一直保持未初始化状态，直至程序执行到相应的 let 语句。
     换句话说，执行到func的时候，解释器知道本词法环境中有x这个变量，所以不往上找了，但是本词法环境中的变量还没有声明，所以它又找不到了。就会出现错误: Cannot access 'x' before initialization
  ,*/
#+end_src
** 函数大军!!!
   #+begin_src js
     function makeFun() {
       i = 1;
       let fun = function() {
         console.log(i);
       };
       i++;
       return fun;
     }
     makeFun()();//输出4，因为调用makeFun()()时，makeFun已经执行完毕了，i=4
   #+end_src

   函数大军的例子：
   #+begin_src js
   function makeArmy() {
  let shooters = [];

  let i = 0;
  while (i < 10) {
    let shooter = function() { // shooter 函数
      alert( i ); // 应该显示其编号
    };
    shooters.push(shooter);
    i++;
  }

  return shooters;
}

let army = makeArmy();

army[0](); // 编号为 0 的 shooter 值为 10
army[5](); // 编号为 5 的 shooter 值也是 10……
// ... 所有的 shooter 的值都是 10，而不是他们的编号 0, 1, 2, 3...
   #+end_src
出现问题的原因与上例makeFun相同，函数执行完毕的时候，i=10，为了解决这个问题，要把i挪到更内部的作用域中：
#+begin_src js
function makeArmy() {
  let shooters = [];

  for (let i = 0; i < 10; i++) { //此时i作用域是for的大括号，生成的每个shooter都记住了其outer作用域中的单独的i值
    let shooter = function() { // shooter 函数
      alert( i ); // 应该显示其编号
    };
    shooters.push(shooter);
  }

  return shooters;
}

let army = makeArmy();

army[0](); // 编号为 0 的 shooter 值为 10
army[5](); // 编号为 5 的 shooter 值也是 10……
// ... 所有的 shooter 的值都是 10，而不是他们的编号 0, 1, 2, 3...
#+end_src
* var和let
** var：变量提升，用模仿块级作用域来规避
** let：不是全局对象的属性
* 全局对象：window/global/globalThis
** 使用全局对象来测试对现代语言功能的支持
   #+begin_src js
   if (!window.Promise) {
  alert("Your browser is really old!");
}
    #+end_src
* 函数对象及命名函数表达式
** 利用函数对象及属性制作计时器，代替闭包计时器
#+begin_src js
  function makeCounterC(){
    //闭包的计时器生成器
    let counter = 0;
    return function(){
      return counter++;
    }

  }

  function makeCounterE(){
    //自定义计时器生成器
    let counterFun = function(){
      return counterFun.counter++;
    }
    counterFun.counter = 0;
    return counterFun;
  }
#+end_src
!!!二者的不同是自定义属性计时器的counter属性可以在外部修改，直接修改counterE.counter就可以了。
但是闭包也可以通过自定义参数来达到这个效果：
#+begin_src js
  function makeCounter(){
    let count = 0;
    return function(option) {
      switch (option) {
      case undefined:
        return count++;
        break;
      case "restore":
        count = 0;
        return count;
        break;
      }
    }
  }
#+end_src
一样的不是嘛？而且可以通过闭包管理计数变量，防止外部修改。
* !!!命名函数表达式：函数内部调用自己时非常好的方式
#+begin_src js
  let funcName = function realFuncName(helloStr) {
    if (helloStr) {
      console.log(helloStr);
    } else {
      realFuncName("you have entered nothing babe!");
    }
  };
#+end_src
** 允许函数通过NFE调用自己
** NFE外部不可见，只有函数内部才可见
好处是如果函数被赋值给了别的变量名，不影响内部调用
** 为counter添加set和decrease方法（闭包法）
!!!这里的重点是，函数的方法和函数共享一个外部词法环境
#+begin_src js
function makeCounter() {
  let count = 0;

  function counter() {
    return count++;
  }

  counter.set = value => count = value;

  counter.decrease = () => count--;

  return counter;
}
#+end_src
** !!任意数量括号求和
#+begin_src js
  function sum(numInit) {
    let accu = numInit;
    adder.toString = () => accu;
    function adder(num){
      accu+=num;
      return adder;
    }
    return adder;
  }
#+end_src
*** !!!这个例子中没有递归！return的是函数adder，但是并没有调用它，这只是闭包，不是递归。
* new Function()语法
语法：
#+begin_src js
let func = new Function ([arg1, arg2, ...argN], functionBody);
#+end_src
** 下列三种声明作用相同
#+begin_src js
new Function('a', 'b', 'return a + b'); // 基础语法
new Function('a,b', 'return a + b'); // 逗号分隔
new Function('a , b', 'return a + b'); // 逗号和空格分隔
#+end_src
** !!!new Function语法没有闭包
#+begin_src js
function getFunc() {
  let value = "test";

  let func = new Function('alert(value)');

  return func;
}

getFunc()(); // error: value is not defined
#+end_src
!!!如果我们使用 new Function 创建一个函数，那么该函数的 [[Environment]] 并不指向当前的词法环境，而是指向全局环境。
例子：
#+begin_src js
let a = 1;
let func = new Funtion("arg", "console.log(arg+a);");
func(1); //2
//因为a在全局环境，所以func可以访问
#+end_src
* setTimeout()和setInterval()
语法：
#+begin_src js
let timerId = setTimeout(func|code, [delay], [arg1], [arg2], ...)
#+end_src
** clearTimeout(timerId)，取消调度。但是timerId的值不会被删除
** clearInterval(timerId)
** 周期性调度的两种方式：
*** 嵌套setTimeout
#+begin_src js
  function runCode(){}
  let timerId = setTimeout(function run(){
    runCode();
    let newTimerId = setTimeout(run, 1000);
  }, 1000);
#+end_src
*** setInterval
** 垃圾回收和 setInterval/setTimeout 回调（callback）
*** 当一个函数传入 setInterval/setTimeout 时，将为其创建一个内部引用，并保存在调度程序中。这样，即使这个函数没有其他引用，也能防止垃圾回收器（GC）将其回收。
*** 函数执行完毕后，timerId还在
*** 零延时实际上不为0
浏览器会将 setTimeout 或 setInterval 的五层或更多层嵌套调用（调用五次之后）的最小延时限制在 4ms。这是历史遗留问题。
对于服务端的 JavaScript，就没有这个限制，并且还有其他调度即时异步任务的方式。例如 Node.js 的 setImmediate。因此，这个提醒只是针对浏览器环境的。
#+begin_src js
let start = Date.now();
let times = [];

setTimeout(function run() {
  times.push(Date.now() - start); // 保存前一个调用的延时

  if (start + 100 < Date.now()) alert(times); // 100 毫秒之后，显示延时信息
  else setTimeout(run); // 否则重新调度
});

// 输出示例：
// 1,1,1,1,9,15,20,24,30,35,40,45,50,55,59,64,70,75,80,85,90,95,100
#+end_src
** 例子
*** 每秒输出一次
#+begin_src js
  let timer1s = setTimeout(function printP1s(from, to) {
    console.log(from);
    if (from !== to) {
      setTimeout(printP1s,1000,from+1,to);
    } else {
      clearTimeout(timer1s);
    }
  },1000,1,10);
  //用函数抽象后的写法（更简洁）
  function printNumbers(from, to) {
    let current = from;

    setTimeout(function go() {
      alert(current);
      if (current < to) {
        setTimeout(go, 1000);
      }
      current++;
    }, 1000);
  }

  // 用例：
  printNumbers(5, 10);
#+end_src
* 函数的透明缓存
#+begin_src js
  function cachingDecorator(func) {
    let cache = new Map();
    return function(x) {//（5）
      if (cache.has(x)) {
        return cache.get(x);
      }

      let result = func(x); //(1)
      cache.set(x, result);
      return result;
    };
  }
  //对于普通函数，上述代码是生效的
  function testFun(number) {return number+1;}
  testFun = cachingDecorator(testFun);
  testFun(5);//6
  testFun(5);//6 直接调用了cache中的值，不需要计算

  /* 下面分析为什么上述代码对于对象方法是失效的*/
  let user = {
    firstName: "jesse",
    lastName: "yang",
    getFullName: function(){
      console.log(this); //新添加一个输出this的语句，方便理解(6)
      return this.firstName+this.lastName;//(2)
    }
  }
  user.getFullName();//"jesseyang"（3）
  user.getFullName = cachingDecorator(user.getFullName); //（4）
  user.getFullName();//NaN

  /*
    (2）行的代码，调用了this，这个this是方法调用的时候分配的.
    未经过包装的情况下调用，（3）行的代码设定了user为this，调用结果正常

    经过（4）行的包装后，user.getFullName实际上变成了（5）行返回的函数

    这个函数处理未经cache的值时，会返回(1)行的调用结果。但是（1）行调用的时候没有传递this

    所以回过头，（2）行的代码在这次调用的时候this是undifined，所以发生了错误

    如果我们在getFullName里面添加一个输出this的语句，可以发现：

    - 未经包装的getFullName，输出了user作为this值
    - 经过包装的getFullName，输出了undefined（浏览器环境输出window，如果没有开启严格模式）
  ,*/

  /* 下面分析如何改进
     只要在（1）行的代码调用时匹配合适的this进去就可以了
     用call方法把this传递进去，所以如果把（1）的语句改成：
     let result = func.call(user,x);执行结果就正确了

     但是这样失去了包装器的意义，因为如果包装了别的对象的方法，这个对象不是user，那么返回值仍然是错误的

     所以可以在（1）行代码上添加：
     let that = this;
     然后修改（1）:let result = func.call(that,x);

     更方便的方法是直接let result = func.call(this,x);
     因为调用(5)行的函数的时候，this被设定成了点号"."前的对象
     那么let result = func.call(this.x);中的this就是这个点。

     问题解决
  ,*/
  //改进的代码如下：
  function cachingDecorator(func) {
    let cache = new Map();
    return function(x) {//（5）
      if (cache.has(x)) {
        return cache.get(x);
      }

      let result = func.call(this,x); //(1)
      cache.set(x, result);
      return result;
    };
  }
#+end_src
* call借助spread语法和rest语法能够做和apply同样的事，但是apply经过引擎优化，大多数时候速度会更快一些
* spread语法与apply的区别：apply仅接受array-like，而spread可以接受iterable
* 多参数的函数包装器
#+begin_src js
let worker = {
  slow(min, max) {
    alert(`Called with ${min},${max}`);
    return min + max;
  }
};

function cachingDecorator(func, hash) {
  let cache = new Map();
  return function() {
    let key = hash(arguments); // (*)
    if (cache.has(key)) {
      return cache.get(key);
    }

    let result = func.apply(this, arguments); // (**)

    cache.set(key, result);
    return result;
  };
}

function hash(args) {
  return args[0] + ',' + args[1];
}

worker.slow = cachingDecorator(worker.slow, hash);

alert( worker.slow(3, 5) ); // works
alert( "Again " + worker.slow(3, 5) ); // same (cached)
#+end_src
** map的key只能是一个值，所以做多参数函数包装器的时候，可以用一个hash函数，将多参数组合成一个key存储在map中
** !!!方法借用
#+begin_src js
//arguments不是数组，所以没有数组的方法，但是可以用下列方式借用数组的join方法
[].join.apply(arguments);
#+end_src
我们从常规数组 [].join 中获取（借用）join 方法，并使用 [].join.call 在 arguments 的上下文中运行它。

它为什么有效？

那是因为原生方法 arr.join(glue) 的内部算法非常简单。

从规范中几乎“按原样”解释如下：

让 glue 成为第一个参数，如果没有参数，则使用逗号 ","。
让 result 为空字符串。
将 this[0] 附加到 result。
附加 glue 和 this[1]。
附加 glue 和 this[2]。
……以此类推，直到 this.length 项目被粘在一起。
返回 result。
因此，从技术上讲，它需要 this 并将 this[0]，this[1] ……等 join 在一起。它的编写方式是故意允许任何类数组的 this 的（不是巧合，很多方法都遵循这种做法）。这就是为什么它也可以和 this=arguments 一起使用。
* 呼叫转移
将一个函数的所有参数连同上下文一起传递给另一个函数称作呼叫转移（call forwarding）
#+begin_src js
let wrapper = function() {
  return func.apply(this, arguments);
};
#+end_src
* !!!装饰器例子
** 间谍装饰者
创建一个装饰者 spy(func)，它应该返回一个包装器，该包装器将所有对函数的调用保存在其 calls 属性中。
每个调用都保存为一个参数数组。
要求
#+begin_src js
function work(a, b) {
  alert( a + b ); // work 是一个任意的函数或方法
}

work = spy(work);

work(1, 2); // 3
work(4, 5); // 9

for (let args of work.calls) {
  alert( 'call:' + args.join() ); // "call:1,2", "call:4,5"
}
#+end_src

解：
#+begin_src js
function work(a,b){
    console.log( a + b);
  }

  function spy(func) {
    function wrapper(...args) {
      wrapper.calls.push(`call:${args.join()}`);
      return func.apply(this, args);
    }
      wrapper.calls = [];
      return wrapper;
  }

  //测试用例
  function sum(...args) {
    return args.reduce((result,number)=>result+=number);
  }

  let seq = {
    vec: [1,2,3,4,5,6,7],
    sum(){
      return this.vec.reduce((result, number)=>result+=number);
    }
  }
#+end_src

*** 拓展知识：[[http://sinonjs.org/][sinonJS]] 单元测试库
** 延时装饰者
将f每次调用延时ms浩渺
要求：
#+begin_src js
function f(x) {
  alert(x);
}

// create wrappers
let f1000 = delay(f, 1000);
let f1500 = delay(f, 1500);

f1000("test"); // 在 1000ms 后显示 "test"
f1500("test"); // 在 1500ms 后显示 "test"
#+end_src

解答：
#+begin_src js
  function delay(func, ms) {
    function delayFunc(...args) {
      setTimeout(()=>func.apply(this,args),ms);//(1)
    }
  }

  //这里有一个问题，实际上返回值不会被收集
#+end_src
!!!setTimeout传递this的坑
普通函数是调用时确定this的，箭头函数是声明时确定this的
所以（1）行的语句，箭头函数声明时获得了this，即dalayFunc被调用时的this
如果用function方式传入回调，需要作出一些调整
#+begin_src js
function delay(f, ms) {

  return function(...args) {
    let savedThis = this; // 将 this 存储到中间变量
    setTimeout(function() {
      f.apply(savedThis, args); // 在这儿使用它
    }, ms);
  };

}
#+end_src


注意这里是如何使用箭头函数的。我们知道，箭头函数没有自己的 this 和 arguments，所以 f.apply(this, arguments) 从包装器中获取 this 和 arguments。

如果我们传递一个常规函数，setTimeout 将调用它且不带参数和 this=window（假设我们在浏览器环境）。
** 去抖装饰者
debounce(f, ms) 装饰者的结果应该是一个包装器，该包装器最多允许每隔 ms 毫秒将调用传递给 f 一次。

换句话说，当我们调用 “debounced” 函数时，它保证之后所有在距离上一次调用的时间间隔少于 ms 毫秒的调用都会被忽略。

在实际中，对于那些用于检索/更新某些内容的函数而言，当我们知道在短时间内不会有什么新内容的时候时，debounce 就显得很有用，因此最好不要浪费资源。

要求：
#+begin_src js
let f = debounce(alert, 1000);

f(1); // 立即执行
f(2); // 被忽略

setTimeout( () => f(3), 100); // 被忽略（只过去了 100 ms）
setTimeout( () => f(4), 1100); // 运行
setTimeout( () => f(5), 1500); // 被忽略（距上一次运行不超过 1000 ms）
#+end_src

解答：
#+begin_src js
    //错误的解法：
    function debounce(func, ms) {
      let lastRunTimeStamp = Date.now();
      function wrapper(...args) {
        let now = Date.now()
        if (now-lastRunTimeStamp >= ms) {
          lastRunTimeStamp = Date.now();
          return func.apply(this, args);
        } else {
          console.log(`debounced, ${1000 - now + lastRunTimeStamp}ms left.`);
        }
      }
      return wrapper;
    }
  f = debounce(console.log, 1000);
  setTimeout( () => f(1), 1000);
  setTimeout( () => f(2), 1500);
  setTimeout( () => f(3), 2000);
  setTimeout( () => f(4), 2500);
  setTimeout( () => f(5), 3000);
  setTimeout( () => f(6), 3500);
  setTimeout( () => f(7), 4000);
  setTimeout( () => f(8), 4500);
  setTimeout( () => f(9), 5000);
  setTimeout( () => f(10), 5500);
  setTimeout( () => f(11), 6000);
  setTimeout( () => f(12), 6500);
  /*
     1
  debounced, 500ms left.
  3
  debounced, 501ms left.
  5
  debounced, 471ms left.
  7
  debounced, 503ms left.
  9
  debounced, 495ms left.
  11
  debounced, 478ms left.
  ,*/

  //这个结果和浏览器的结果是不同的，浏览器的1000整数倍ms很多会被debounce掉
#+end_src

正确解法：
#+begin_src js
function debounce(f, ms) {

  let isCooldown = false;

  return function() {
    if (isCooldown) return;

    f.apply(this, arguments);

    isCooldown = true;

    setTimeout(() => isCooldown = false, ms);
  };

}
#+end_src
** 节流装饰者
#+begin_src js
function throttle(f, ms) {

  let isThrottled = false,
    savedArgs,
    savedThis;

  function wrapper() {

    if (isThrottled) { // (2)
      savedArgs = arguments;
      savedThis = this;
      return;
    }

    f.apply(this, arguments); // (1)

    isThrottled = true;

    setTimeout(function() {
      isThrottled = false; // (3)
      if (savedArgs) {
        wrapper.apply(savedThis, savedArgs);
        savedArgs = savedThis = null;
      }
    }, ms);
  }

  return wrapper;
}
#+end_src
* Object.keys()、for...of都只能遍历对象自身的属性，for...in可以遍历原型链上的属性
* 原型链的顶端是null
|                 | null               |                  |
|-----------------+--------------------+------------------|
|                 | Object.prototype   |                  |
| Array.prototype | Function.prototype | Number.prototype |
| [1,2,3]         | function(args){}   |                5 |
|-----------------+--------------------+------------------|
Function.prototype是函数 ~Function()~ 的一个常规属性，new Function()出来的对象有一个__proto__属性指向Function.prototype
** 每个函数都自带一个.prototype属性。这个属性是一个对象，无论是否被另行指定。这个对象里面带有一个.constructor属性，指向函数自身。
** 原型的例子
*** 给函数添加一个f.defer(ms)方法
在所有函数的原型中添加 defer(ms) 方法，该方法将在 ms 毫秒后运行该函数。

当你完成添加后，下面的代码应该是可执行的：
#+begin_src js
function f() {
  alert("Hello!");
}

f.defer(1000); // 1 秒后显示 "Hello!"
#+end_src

解答：
#+begin_src js
  Function.prototype.defer = function(ms) {
    setTimeout(this, ms);
  };

  function f() {
    alert("Hello!");
  }

  f.defer(1000); // shows "Hello!" after 1 sec
#+end_src
*** 将装饰者defer()添加到函数
在所有函数的原型中添加 defer(ms) 方法，该方法返回一个包装器，将函数调用延迟 ms 毫秒。

下面是它应该如何执行的例子：
#+begin_src js
  function f(a, b) {
    alert( a + b );
  }

  f.defer(1000)(1, 2); // 1 秒后显示 3
#+end_src

解答：!!!教材的标准答案适用于对象的方法
#+begin_src js
  Function.prototype.defer = function(ms) {
    return (...args) => setTimeout(this, ms, ...args);
  }

  // 教程的标准答案

  Function.prototype.defer = function(ms) {
    let f = this;
    return function(...args) {
      setTimeout(() => f.apply(this, args), ms);
    }
  };

  // check it
  function f(a, b) {
    alert( a + b );
  }

  f.defer(1000)(1, 2); // 1 秒后显示 3

  // 教程标准答案适用于对象方法

  let user = {
    name: "John",
    sayHi() {
      alert(this.name);
    }
  }

  user.sayHi = user.sayHi.defer(1000);

  user.sayHi();
#+end_src
* 原型方法
** Object.create(proto[, descriptors])
!!!真正的浅拷贝（完全一致）
#+begin_src js
  // 完全相同的对象 obj 的浅拷贝
  let clone = Object.create(Object.getPrototypeOf(obj), Object.getOwnPropertyDescriptors(obj));
#+end_src
** Object.getPrototypeOf(obj)
** Object.setPrototypeOf(obj,proto)
以上两项相当于__proto__的访问器

** "Very plain" objects（纯白对象）
__proto__属性很特别：它必须是对象或者 null。字符串不能成为 prototype。
这个例子：
#+begin_src js
let obj = {};

let key = prompt("What's the key?", "__proto__");
obj[key] = "some value";

alert(obj[key]); // [object Object]，并不是 "some value"！
#+end_src

我们可能会对对象进行赋值操作，然后原型可能就被更改了。结果，可能会导致完全意想不到的结果。

最可怕的是 —— 通常开发者完全不会考虑到这一点。这让此类 bug 很难被发现，甚至变成漏洞，尤其是在 JavaScript 被用在服务端的时候。

为默认情况下为函数的 toString 以及其他内建方法执行赋值操作，也会出现意想不到的结果。

*** 使用map可以解决这个问题
*** 创建纯白对象（very plain objects）
#+begin_src js
let obj = Object.create(null);

let key = prompt("What's the key?", "__proto__");
obj[key] = "some value";

alert(obj[key]); // "some value"
#+end_src
** 遍历对象的属性的方法
Object.keys(obj) / Object.values(obj) / Object.entries(obj) —— 返回一个可枚举的由自身的字符串属性名/值/键值对组成的数组。
Object.getOwnPropertySymbols(obj) —— 返回一个由自身所有的 symbol 类型的键组成的数组。
Object.getOwnPropertyNames(obj) —— 返回一个由自身所有的字符串键组成的数组。
Reflect.ownKeys(obj) —— 返回一个由自身所有键组成的数组。
obj.hasOwnProperty(key)：如果 obj 拥有名为 key 的自身的属性（非继承而来的），则返回 true。
** polyfill Array.prototype.repeat的例子
#+begin_src js
  if (!String.prototype.repeat) { // 如果这儿没有这个方法
    // 那就在 prototype 中添加它

    String.prototype.repeat = function(n) {
      // 重复传入的字符串 n 次

      // 实际上，实现代码比这个要复杂一些（完整的方法可以在规范中找到）
      // 但即使是不够完美的 polyfill 也常常被认为是足够好的
      return new Array(n + 1).join(this);
    };
  }

  alert( "La".repeat(3) ); // LaLaLa
#+end_src
